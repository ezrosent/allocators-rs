// Copyright 2017-2018 the authors. See the 'Copyright and license' section of
// the README.md file at the top-level directory of this repository.
//
// Licensed under the Apache License, Version 2.0 (the LICENSE-APACHE file) or
// the MIT license (the LICENSE-MIT file) at your option. This file may not be
// copied, modified, or distributed except according to those terms.

//! Bindings for the C `malloc` API to Rust allocators.
//!
//! This crate provides a mechanism to construct a C allocator - implementations of `malloc`,
//! `free`, and related functions - that is backed by a Rust allocator (an implementation of the
//! `Alloc` trait).
//!
//! In order to create bindings, an implementation of the `Alloc` trait must be extended to also
//! implement the `LayoutFinder` and `Malloc` traits (defined in this crate). The `Malloc` trait
//! provides one method for each function in the C API (default implementations are provided which
//! use the methods of the `Alloc` trait, but these can be overridden if needed). Since the C API
//! does not provide size or alignment when passing a pointer to an existing allocation (`free`,
//! `realloc`, etc), but the Rust `Alloc` API requires both size and alignment for these methods,
//! a mapping must be maintained between allocated objects and those objects' size and alignment.
//! The `LayoutFinder` trait provides this functionality.

// TODO:
// - Windows:
//   - Support _heapmin (https://msdn.microsoft.com/en-us/library/fc7etheh.aspx)
//   - Support _set_new_handler (https://msdn.microsoft.com/en-us/library/a45x8asx.aspx) (and call
//     the registered handler in various functions)

#![no_std]
#![feature(allocator_api)]
#![feature(alloc)]
#![feature(core_intrinsics)]
#![feature(const_fn)]
#![feature(const_size_of)]

#[cfg(not(any(target_os = "linux", target_os = "macos", windows)))]
compile_error!("malloc-bind only supports Linux, and Mac, and Windows");

extern crate alloc;
extern crate errno;
extern crate libc;
#[cfg(any(target_os = "linux", target_os = "macos"))]
extern crate sysconf;
// lazy_static's macros are only used in the macros we define, so if no macros are called (which is
// the case when compiling this crate on its own), then lazy_static's macros (and thus the
// #[macro_use] attribute) will appear unused.
#[allow(unused_imports)]
#[macro_use]
extern crate lazy_static;
use alloc::alloc::{GlobalAlloc, Layout};

// Export these so that they can be used from the macros as $crate::c_void and $crate::size_t.
// See https://users.rust-lang.org/t/how-to-import-in-a-macro-without-conflicting/12785 for why
// this is necessary.
use core::intrinsics::unlikely;
use core::ptr;
#[doc(hidden)]
pub use libc::{c_void, size_t};

/// A mechanism for mapping allocated objects to their `Layout`s.
///
/// A `LayoutFinder` is an object that can store and look up the `Layout` associated with an
/// allocated object. In the functions generated by this crate, newly-allocated objects will be
/// inserted into a global `LayoutFinder` object, and this `LayoutFinder` will be used to look up
/// the `Layout`s associated with objects passed to `free` and other functions.
///
/// # Safety
///
/// This trait is unsafe because an incorrect implementation could result in invalid arguments
/// getting passed to unsafe methods of the `Alloc` trait.
pub unsafe trait LayoutFinder {
    /// Get the `Layout` associated with an allocated object.
    ///
    /// `get_layout` is passed a pointer to an allocated object, and it returns a `Layout`
    /// describing that object. `ptr` is guaranteed to be an object previously allocated using one
    /// of the various C allocation functions.
    ///
    /// # Safety
    ///
    /// This method is unsafe because implementations may dereference `ptr`, rely on it having been
    /// allocated by this allocator, or rely on it having been inserted using `insert_layout`.
    unsafe fn get_layout(&self, ptr: *mut u8) -> Layout;

    /// Insert a new object to `Layout` mapping.
    ///
    /// `insert_layout` is passed a pointer to a newly-allocated object and a `Layout` describing
    /// that object, and it stores this mapping. `insert_layout` is called immediately after
    /// allocation in all of the C allocation functions.
    ///
    /// The default implementation of `insert_layout` is a no-op, as some allocators may already
    /// keep track of the information necessary to implement `get_layout` internally.
    ///
    /// # Safety
    ///
    /// This method is unsafe because implementations may dereference `ptr`, rely on it having been
    /// allocated by this allocator, or rely on it not having already been inserted.
    unsafe fn insert_layout(&self, _ptr: *mut u8, _layout: Layout) {}

    /// Delete an existing object to `Layout` mapping.
    ///
    /// `delete_layout` is passed a pointer to an object whose mapping has previously been
    /// inserted, and it deletes this mapping. `delete_layout` is called immediately after
    /// deallocation in all of the C deallocation functions.
    ///
    /// The default implementation of `delete_layout` is a no-op, as some allocators may already
    /// keep track of the information necessary to implement `get_layout` internally.
    ///
    /// # Safety
    ///
    /// This method is unsafe because implementations may dereference `ptr`, rely on it having been
    /// allocated by this allocator, or rely on it already having been inserted using
    /// `insert_layout`.
    unsafe fn delete_layout(&self, _ptr: *mut u8) {}
}

// See the posix_memalign manpage on Linux, the malloc manpage on Mac, or
// https://msdn.microsoft.com/en-us/library/6ewkz86d.aspx on Windows.
//
// According to the Linux posix_memalign manpage, "The glibc malloc(3) always returns 8-byte
// aligned memory addresses..." According to the Mac malloc manpage, "The allocated memory is
// aligned such that it can be used for any data type, including AltiVec- and SSE-related types."
// According to the linked Windows documentation, "The storage space pointed to by the return value
// is guaranteed to be suitably aligned for storage of any type of object that has an alignment
// requirement less than or equal to that of the fundamental alignment. (In Visual C++, the
// fundamental alignment is the alignment that's required for a double, or 8 bytes. In code that
// targets 64-bit platforms, itâ€™s 16 bytes.)"
//
// Thus, we align all allocations to these alignments. Since the Rust Layout type requires that
// size be a multiple of alignment, we also round up the size to be a multiple of the alignment.
//
// On Linux, it is valid for malloc(0) to return NULL, so for all 0-sized allocations, we return
// NULL. On Mac, this allowance is not explicitly documented, so we err on the side of caution and
// round up 0-sized allocations as we would any other allocation. On Windows, it is explicitly
// documented that 0-sized allocations return pointers into the heap: "If size is 0, malloc
// allocates a zero-length item in the heap and returns a valid pointer to that item." Thus, we
// round up 0-sized allocations on Windows as well.

/// The minimum alignment guaranteed by some allocation functions.
///
/// Some allocation functions guarantee an alignment of `MIN_ALIGN`. This alignment is 8 on Linux
/// and 32-bit Windows, and 16 on Mac and 64-bit Windows.
pub const MIN_ALIGN: size_t = __MIN_ALIGN;

#[cfg(not(any(target_os = "macos", all(windows, target_pointer_width = "64"))))]
const __MIN_ALIGN: size_t = 8;
#[cfg(any(target_os = "macos", all(windows, target_pointer_width = "64")))]
const __MIN_ALIGN: size_t = 16;

/// The size of a C `void *`.
///
/// `WORD_SIZE` is the size of a pointer, equivalent to `sizeof(void *)` in C.
pub const WORD_SIZE: usize = core::mem::size_of::<*mut c_void>();

/// An implementation of the C allocation API.
///
/// The `Malloc` trait extends a type which implements `Alloc` for a reference to
/// itself<sup>1</sup> by
/// providing methods for the various functions of the C allocation API. As `Malloc` also extends
/// `LayoutFinder`, it provides default implementations of each method in terms of the
/// `LayoutFinder` and `Alloc` methods. Alternatively, any method may be overridden with a custom
/// implementation.
///
/// Having implemented `Malloc`, most users will want to use the `define_malloc` or
/// `define_malloc_lazy_static` macros, which take care of wrapping each method in an `extern "C"`
/// function that can be called from C code. Users who wish to expose only a subset of this API
/// will need to define the `extern "C"` functions manually.
///
/// 1. `Malloc` requires an immutable reference to implement `Alloc` (rather than simply extending
///    `Alloc` itself) so that its own methods can be immutable. This is required because C allows
///    the functions of the allocation API to be called from multiple threads at once.
pub unsafe trait Malloc: GlobalAlloc + LayoutFinder {
    /// The C `malloc` function.
    ///
    /// `malloc` allocates storage sufficient to hold `size` bytes, and returns a pointer to it.
    /// The allocated memory is aligned to `MIN_ALIGN`. The memory is not initialized. If there is
    /// insufficient space to perform the allocation, `errno` is set to `ENOMEM` and the return
    /// value is `NULL`.
    ///
    /// # Platform-specific behavior
    ///
    /// On Linux, if `size` is 0, `malloc` returns either `NULL` or a unique pointer that can later
    /// be passed to `free`. On Mac and Windows, if `size` is 0, an allocation must still be
    /// created on the heap such that two different 0-sized allocations result in two distinct
    /// pointers.
    unsafe fn c_malloc(&self, size: size_t) -> *mut c_void {
        if cfg!(target_os = "linux") && unlikely(size == 0) {
            return ptr::null_mut();
        }

        let size = roundup(size, MIN_ALIGN);
        let layout = layout_from_size_align(size as usize, MIN_ALIGN);
        // TODO: Check _HEAP_MAXREQ on Windows? "malloc sets errno to ENOMEM if a memory allocation
        // fails or if the amount of memory requested exceeds _HEAP_MAXREQ."
        let ptr = self.alloc(layout.clone());
        if !ptr.is_null() {
            self.insert_layout(ptr, layout);
        } else {
            errno::set_errno(errno::Errno(libc::ENOMEM));
        }
        ptr as *mut c_void
    }

    /// The C `free` function.
    ///
    /// `free` frees a previous allocation. If `ptr` is `NULL`, `free` does nothing. The behavior
    /// of `free` is undefined if `ptr` does not represent a previous allocation, or if `ptr` has
    /// already been freed.
    unsafe fn c_free(&self, ptr: *mut c_void) {
        if unlikely(ptr.is_null()) {
            // Linux/Mac: "If ptr is a NULL pointer, no operation is performed."
            // Windows: "If memblock is NULL, the pointer is ignored and free immediately returns."
            return;
        }

        let layout = self.get_layout(ptr as *mut u8);
        self.delete_layout(ptr as *mut u8);
        self.dealloc(ptr as *mut u8, layout);
    }

    /// The obsolete C `cfree` function (only implemented on Linux).
    ///
    /// `cfree` is an alias for `free`.
    #[cfg(target_os = "linux")]
    unsafe fn c_cfree(&self, ptr: *mut c_void) {
        // See https://linux.die.net/man/3/cfree
        self.c_free(ptr)
    }

    /// The C `calloc` function.
    ///
    /// `calloc` allocates storage sufficient to hold `nmemb` elements of size `size` and returns a
    /// pointer to it. The allocated memory is aligned to `MIN_ALIGN`. The memory is initialized to
    /// zero. If there is insufficient space to perform the allocation, `errno` is set to `ENOMEM`
    /// and the return value is `NULL`.
    ///
    /// # Platform-specific behavior
    ///
    /// On Linux, if either `size` or `nmemb` are 0, `calloc` returns either `NULL` or a unique
    /// pointer that can later be passed to `free`. On Mac and Windows, if either `size` or `nmemb`
    /// are 0, an allocation must still be created on the heap such that two different 0-sized
    /// allocations result in two distinct pointers.
    unsafe fn c_calloc(&self, nmemb: size_t, size: size_t) -> *mut c_void {
        if cfg!(target_os = "linux") && unlikely(nmemb == 0 || size == 0) {
            return ptr::null_mut();
        }

        let total_size = roundup(nmemb * size, MIN_ALIGN);
        let layout = layout_from_size_align(total_size as usize, MIN_ALIGN);
        // TODO: Check _HEAP_MAXREQ on Windows? "calloc sets errno to ENOMEM if a memory allocation
        // fails or if the amount of memory requested exceeds _HEAP_MAXREQ."
        let ptr = self.alloc_zeroed(layout.clone());
        if !ptr.is_null() {
            self.insert_layout(ptr, layout);
        } else {
            errno::set_errno(errno::Errno(libc::ENOMEM));
        }
        ptr as *mut c_void
    }

    /// The obsolete C `valloc` function (only implemented on Linux and Mac).
    ///
    /// `valloc` allocates storage sufficient to hold `size` bytes, and returns a pointer to it.
    /// The allocated memory is aligned to the system's page size. The memory is not initialized.
    /// If there is insufficient space to perform the allocation, `errno` is set to `ENOMEM` and
    /// the return value is `NULL`.
    ///
    /// # Platform-specific behavior
    ///
    /// On Linux, if `size` is 0, `valloc` returns either `NULL` or a unique pointer that can later
    /// be passed to `free`. On Mac, if `size` is 0, an allocation must still be created on the
    /// heap such that two different 0-sized allocations result in two distinct pointers.
    #[cfg(any(target_os = "linux", target_os = "macos"))]
    unsafe fn c_valloc(&self, size: size_t) -> *mut c_void {
        if cfg!(target_os = "linux") && unlikely(size == 0) {
            return ptr::null_mut();
        }

        let pagesize = sysconf::page::pagesize();
        let size = roundup(size, pagesize);
        let layout = layout_from_size_align(size as usize, pagesize);
        let ptr = self.alloc(layout.clone());
        if !ptr.is_null() {
            self.insert_layout(ptr, layout);
        } else {
            errno::set_errno(errno::Errno(libc::ENOMEM));
        }
        ptr as *mut c_void
    }

    /// The obsolete C `pvalloc` function (only implemented on Linux).
    ///
    /// `pvalloc` is like `valloc`, except that `size` is rounded up to the next multiple of the
    /// system's page size.
    #[cfg(target_os = "linux")]
    unsafe fn c_pvalloc(&self, size: size_t) -> *mut c_void {
        // See http://man7.org/linux/man-pages/man3/posix_memalign.3.html

        if unlikely(size == 0) {
            return ptr::null_mut();
        }

        let pagesize = sysconf::page::pagesize();
        let size = roundup(size, pagesize);
        let layout = layout_from_size_align(size as usize, pagesize);
        let ptr = self.alloc(layout.clone());
        if !ptr.is_null() {
            self.insert_layout(ptr, layout);
        } else {
            errno::set_errno(errno::Errno(libc::ENOMEM));
        }
        ptr as *mut c_void
    }

    /// The C `realloc` function.
    ///
    /// `realloc` changes the size of the allocation pointed to by `ptr` to `size` bytes, returning
    /// the address of the modified allocation (which may be different from `ptr`). The contents
    /// will be unchanged in the range from the start of the allocation to the minimum of the old
    /// and new sizes. If the new size is larger than the old size, the added memory will not be
    /// initialized. If `ptr` is `NULL`, then the call is equivalent to `malloc(size)`. If the
    /// allocation request fails, the original allocation is left untouched, `errno` is set to
    /// `ENOMEM`, and the return value is `NULL`.
    ///
    /// # Platform-specific behavior
    ///
    /// On Linux and Windows, if `size` is 0 and `ptr` is not `NULL`, then `realloc` is equivalent
    /// to `free(ptr)`, and the return value is `NULL`. On Mac, if `size` is 0 and `ptr` is not
    /// `NULL`, then `realloc` allocates a new 0-sized object with the same guarantees as
    /// `malloc(0)` and, if this allocation succeeds, frees `ptr`.
    unsafe fn c_realloc(&self, ptr: *mut c_void, size: size_t) -> *mut c_void {
        // See http://man7.org/linux/man-pages/man3/malloc.3.html,
        // http://www.manpagez.com/man/3/malloc/osx-10.6.php

        if ptr.is_null() {
            // Linux: "If ptr is NULL, then the call is equivalent to malloc(size), for all values
            // of size."
            // Mac: "If ptr is NULL, realloc() is identical to a call to malloc() for size bytes."
            // Windows: "If memblock is NULL, realloc behaves the same way as malloc and allocates
            // a new block of size bytes."
            return self.c_malloc(size);
        }

        if cfg!(any(target_os = "linux", windows)) && unlikely(size == 0) {
            // Linux: "if size is equal to zero, and ptr is not NULL, then the call is equivalent
            // to free(ptr)."
            // Windows (https://msdn.microsoft.com/en-us/library/xbebcx7d.aspx): "If size is zero,
            // then the block pointed to by [ptr] is freed; the return value is NULL, and [ptr] is
            // left pointing at a freed block."
            self.c_free(ptr);
            return ptr::null_mut();
        }

        // Mac: "If size is zero and ptr is not NULL, a new, minimum sized object is allocated
        // and the original object is freed."
        //
        // Since "minimum sized object" isn't defined in the manpage, we take it to mean an object
        // at least as large as the minimum alignment. Luckily, we don't need any special-cased
        // logic since 'roundup(size, MIN_ALIGN)' will handle this for us. Note that while the
        // manpage requires that a new object is allocated and the old one freed, realloc'ing works
        // just as well because the caller cannot rely on the contents of a newly-allocated object,
        // and thus the new object sharing memory with the old object is fine.

        let size = roundup(size, MIN_ALIGN);
        let layout = self.get_layout(ptr as *mut u8);
        let new_layout = layout_from_size_align(size as usize, MIN_ALIGN);
        let ptr = self.alloc(layout.clone());
        if !ptr.is_null() {
            self.delete_layout(ptr);
            self.insert_layout(ptr, new_layout);
        } else {
            // Linux: "The realloc() function returns... NULL if the request
            // fails... If realloc() fails, the original block is left
            // untouched; it is not freed or moved."
            // Mac: "If there is an error, [realloc] return[s] a NULL pointer
            // and set[s] errno to ENOMEM. For realloc(), the input pointer is
            // still valid if reallocation failed."
            // Windows: "If there is not enough available memory to expand the
            // block to the given size, the original block is left unchanged,
            // and NULL is returned."
            errno::set_errno(errno::Errno(libc::ENOMEM));
        }
        ptr as *mut c_void
    }

    /// The C `reallocf` function (only implemented on Mac).
    ///
    /// `reallocf` is like `realloc`, except that if the requested memory cannot be allocated,
    /// `ptr` will be freed.
    #[cfg(target_os = "macos")]
    unsafe fn c_reallocf(&self, ptr: *mut c_void, size: size_t) -> *mut c_void {
        // See http://www.manpagez.com/man/3/malloc/osx-10.6.php

        if ptr.is_null() {
            return self.c_malloc(size);
        }

        // According to the reallocf manpage: "If size is zero and ptr is not NULL, a new, minimum
        // sized object is allocated and the original object is freed." See the equivalent comment
        // in realloc for why this is handled automatically.

        let size = roundup(size, MIN_ALIGN);
        let layout = self.get_layout(ptr as *mut u8);
        let new_layout = layout_from_size_align(size as usize, MIN_ALIGN);
        let ptr = self.alloc(layout.clone());
        if !ptr.is_null() {
            self.delete_layout(ptr);
            self.insert_layout(ptr, new_layout);
        } else {
            self.c_free(ptr as *mut c_void);
            errno::set_errno(errno::Errno(libc::ENOMEM));
        }
        ptr as *mut c_void
    }

    /// The C `posix_memalign` function (only implemented on Linux and Mac).
    ///
    /// `posix_memalign` allocates storage sufficient to hold `size` bytes, writing a pointer to it
    /// to the location referenced by `memptr`. The address of the allocation will be a a multiple
    /// of `alignment`, which must be a power of two and a multiple of `WORD_SIZE`. On success,
    /// `posix_memalign` returns 0.
    ///
    /// # Errors
    ///
    /// - If `alignment` is not a power of two multiple of `WORD_SIZE`, `posix_memalign` performs
    ///   no allocation, and instead returns `EINVAL`.
    /// - If there is not sufficient memory to satisfy the request, `posix_memalign` returns
    ///   `ENOMEM`.
    ///
    /// # Platform-specific behavior
    ///
    /// On Linux, if `size` is 0, the value placed in `*memptr` is either `NULL` or a unique value
    /// that can later be passed to `free`. On Mac, if `size` is 0, an allocation must still be
    /// created on the heap such that two different 0-sized allocations result in two distinct
    /// pointers.
    #[cfg(any(target_os = "linux", target_os = "macos"))]
    unsafe fn c_posix_memalign(
        &self,
        memptr: *mut *mut c_void,
        alignment: size_t,
        size: size_t,
    ) -> i32 {
        // See http://man7.org/linux/man-pages/man3/posix_memalign.3.html

        // NOTE: Unlike most other allocation functions, posix_memalign signals failure by
        // returning an error value rather than by setting errno.

        // The manpage also specifies that the alignment must be a multiple of the word size, but
        // all powers of two greater than or equal to the word size are multiples of the word size,
        // so we omit that check.
        if unlikely(alignment <= WORD_SIZE || !alignment.is_power_of_two()) {
            return libc::EINVAL;
        }

        if cfg!(target_os = "linux") && unlikely(size == 0) {
            *memptr = ptr::null_mut();
            return 0;
        }

        // posix_memalign does not require that size is a multiple of alignment. Thus, we manually
        // round up since valid Layouts must have that property. This is safe because this API
        // never takes the memory region size on deallocation, so it's fine that the caller might
        // think they have a smaller memory region than they actually do.
        let size = roundup(size, alignment);
        let layout = layout_from_size_align(size as usize, alignment);
        let ptr = self.alloc(layout.clone());
        if !ptr.is_null() {
            self.insert_layout(ptr, layout);
            *memptr = ptr as *mut c_void;
            0
        } else {
            libc::ENOMEM
        }
    }

    /// The obsolete C `memalign` function (only implemented on Linux).
    ///
    /// `memalign` allocates storage sufficient to hold `size` bytes, returning a pointer to it.
    /// The address of the allocation will be a a multiple of `alignment`, which must be a power of
    /// two (unlike `posix_memalign`, it does not need to be a multiple of `WORD_SIZE`).
    ///
    /// # Errors
    ///
    /// - If `alignment` is not a power of two, `memalign` performs no allocation, sets `errno` to
    ///   `EINVAL`, and returns `NULL`.
    /// - If there is not sufficient memory to satisfy the request, `memalign` sets `errno` to
    ///   `ENOMEM` and returns `NULL`.
    #[cfg(target_os = "linux")]
    unsafe fn c_memalign(&self, alignment: size_t, size: size_t) -> *mut c_void {
        // See http://man7.org/linux/man-pages/man3/posix_memalign.3.html

        if unlikely(!alignment.is_power_of_two()) {
            errno::set_errno(errno::Errno(libc::EINVAL));
            return ptr::null_mut();
        }

        if unlikely(size == 0) {
            return ptr::null_mut();
        }

        // memalign does not require that size is a multiple of alignment. Thus, we manually round
        // up since valid Layouts must have that property. This is safe because this API never
        // takes the memory region size on deallocation, so it's fine that the caller might think
        // they have a smaller memory region than they actually do.
        let size = roundup(size, alignment);
        let layout = layout_from_size_align(size as usize, alignment);
        let ptr = self.alloc(layout.clone());
        if !ptr.is_null() {
            self.insert_layout(ptr, layout);
        } else {
            errno::set_errno(errno::Errno(libc::ENOMEM));
        }
        ptr as *mut c_void
    }

    /// The C `aligned_alloc` function (only implemented on Linux).
    ///
    /// `aligned_alloc` is like `memalign`, except that `size` must be a multiple of `alignment`,
    /// or else `aligned_alloc` will perform no allocation, set `errno` to `EINVAL`, and return
    /// `NULL`.
    #[cfg(target_os = "linux")]
    unsafe fn c_aligned_alloc(&self, alignment: size_t, size: size_t) -> *mut c_void {
        // See http://man7.org/linux/man-pages/man3/posix_memalign.3.html

        // From the aligned_alloc manpage: "The function aligned_alloc() is the same as memalign(),
        // except for the added restriction that size should be a multiple of alignment."
        if unlikely(!alignment.is_power_of_two() || size % alignment != 0) {
            errno::set_errno(errno::Errno(libc::EINVAL));
            return ptr::null_mut();
        }
        self.c_memalign(alignment, size)
    }

    /// The C '_aligned_malloc' function (only implemented on Windows).
    ///
    /// `_aligned_malloc` allocates storage sufficient to hold `size` bytes, returning a pointer to
    /// it. The address of the allocation will be a a multiple of `alignment`, which must be a
    /// power of two (unlike `posix_memalign`, it does not need to be a multiple of `WORD_SIZE`).
    /// The `size` must be non-zero.
    ///
    /// # Errors
    ///
    /// - If `alignment` is not a power of two or `size` is 0, `_aligned_malloc` performs no
    ///   allocation, sets `errno` to `EINVAL`, and returns `NULL`.
    /// - If there is not sufficient memory to satisfy the request, `_aligned_malloc` sets `errno`
    ///   to `ENOMEM` and returns `NULL`.
    #[cfg(windows)]
    #[allow(non_snake_case)]
    unsafe fn c__aligned_malloc(&self, size: size_t, alignment: size_t) -> *mut c_void {
        // See https://msdn.microsoft.com/en-us/library/8z34s9c6.aspx

        if unlikely(!alignment.is_power_of_two() || size == 0) {
            // TODO: Call invalid parameter handler (see documentation). Blocked on this issue:
            // https://github.com/retep998/winapi-rs/issues/493
            errno::set_errno(errno::Errno(libc::EINVAL));
            return ptr::null_mut();
        }

        // _aligned_malloc does not require that size is a multiple of alignment. Thus, we manually
        // round up since valid Layouts must have that property. This is safe because this API
        // never takes the memory region size on deallocation, so it's fine that the caller might
        // think they have a smaller memory region than they actually do.
        let size = roundup(size, alignment);
        let layout = layout_from_size_align(size as usize, alignment);
        let ptr = self.alloc(layout.clone());
        if !ptr.is_null() {
            self.insert_layout(ptr, layout);
        } else {
            errno::set_errno(errno::Errno(libc::ENOMEM));
        }
        ptr as *mut c_void
    }
}

#[cfg_attr(feature = "cargo-clippy", allow(inline_always))]
#[inline(always)]
fn roundup(n: size_t, multiple: size_t) -> size_t {
    if n == 0 {
        return multiple;
    }
    let remainder = n % multiple;
    if remainder == 0 {
        n
    } else {
        n + multiple - remainder
    }
}

#[cfg_attr(feature = "cargo-clippy", allow(inline_always))]
#[inline(always)]
unsafe fn layout_from_size_align(size: usize, align: usize) -> Layout {
    if cfg!(debug_assertions) {
        Layout::from_size_align(size as usize, align).unwrap()
    } else {
        Layout::from_size_align_unchecked(size as usize, align)
    }
}

// TODO: In the macros, how do we ensure that the right types are imported (Malloc, size_t, c_void)
// while not conflicting with existing imports if they're already imported.

/// Define `extern "C"` functions for the C allocation API.
///
/// `define_malloc` is a convenience macro that constructs a global instance of a `Malloc` type and
/// defines each of the functions of the C allocation API by calling methods on that instance. One
/// function is defined for each of the methods on `Malloc` (`malloc` for the `c_malloc` method,
/// `free` for the `c_free` method, etc). Users who only want to define a subset of the C
/// allocation API should instead define these functions manually.
///
/// `define_malloc` takes an allocator type and an expression to construct a new instance of that
/// type. The expression must be a constant expression, as it will be used in the initialization of
/// a static variable. If the expression needs to be non-constant, use `define_malloc_lazy_static`
/// instead.
#[macro_export]
macro_rules! define_malloc {
    ($alloc_ty:ty, $alloc_new:expr) => {
        static __HEAP: $alloc_ty = $alloc_new;

        #[no_mangle]
        pub extern "C" fn malloc(size: $crate::size_t) -> *mut $crate::c_void {
            // Do this here (rather than at the top-level) so as not to conflict with existing
            // macros if the user has already imported Malloc.
            use $crate::Malloc;
            unsafe { __HEAP.c_malloc(size) }
        }

        #[no_mangle]
        pub extern "C" fn free(ptr: *mut $crate::c_void) {
            use $crate::Malloc;
            unsafe { __HEAP.c_free(ptr) }
        }

        #[cfg(target_os = "linux")]
        #[no_mangle]
        pub extern "C" fn cfree(ptr: *mut $crate::c_void) {
            use $crate::Malloc;
            unsafe { __HEAP.c_cfree(ptr) }
        }

        #[no_mangle]
        pub extern "C" fn calloc(
            nmemb: $crate::size_t,
            size: $crate::size_t,
        ) -> *mut $crate::c_void {
            use $crate::Malloc;
            unsafe { __HEAP.c_calloc(nmemb, size) }
        }

        #[cfg(any(target_os = "linux", target_os = "macos"))]
        #[no_mangle]
        pub extern "C" fn valloc(size: $crate::size_t) -> *mut $crate::c_void {
            use $crate::Malloc;
            unsafe { __HEAP.c_valloc(size) }
        }

        #[cfg(target_os = "linux")]
        #[no_mangle]
        pub extern "C" fn pvalloc(size: $crate::size_t) -> *mut $crate::c_void {
            use $crate::Malloc;
            unsafe { __HEAP.c_pvalloc(size) }
        }

        #[no_mangle]
        pub extern "C" fn realloc(
            ptr: *mut $crate::c_void,
            size: $crate::size_t,
        ) -> *mut $crate::c_void {
            use $crate::Malloc;
            unsafe { __HEAP.c_realloc(ptr, size) }
        }

        #[cfg(target_os = "macos")]
        #[no_mangle]
        pub extern "C" fn reallocf(
            ptr: *mut $crate::c_void,
            size: $crate::size_t,
        ) -> *mut $crate::c_void {
            use $crate::Malloc;
            unsafe { __HEAP.c_reallocf(ptr, size) }
        }

        #[cfg(any(target_os = "linux", target_os = "macos"))]
        #[no_mangle]
        pub extern "C" fn posix_memalign(
            memptr: *mut *mut $crate::c_void,
            alignment: $crate::size_t,
            size: $crate::size_t,
        ) -> i32 {
            use $crate::Malloc;
            unsafe { __HEAP.c_posix_memalign(memptr, alignment, size) }
        }

        #[cfg(target_os = "linux")]
        #[no_mangle]
        pub extern "C" fn memalign(
            alignment: $crate::size_t,
            size: $crate::size_t,
        ) -> *mut $crate::c_void {
            use $crate::Malloc;
            unsafe { __HEAP.c_memalign(alignment, size) }
        }

        #[cfg(target_os = "linux")]
        #[no_mangle]
        pub extern "C" fn aligned_alloc(
            alignment: $crate::size_t,
            size: $crate::size_t,
        ) -> *mut $crate::c_void {
            use $crate::Malloc;
            unsafe { __HEAP.c_aligned_alloc(alignment, size) }
        }

        #[cfg(windows)]
        #[no_mangle]
        pub extern "C" fn _aligned_malloc(
            size: $crate::size_t,
            alignment: $crate::size_t,
        ) -> *mut $crate::c_void {
            use $crate::Malloc;
            unsafe { __HEAP.c__aligned_malloc(size, alignment) }
        }
    };
}

// This line re-exports the macros from lazy_static so that they'll be available to the code
// calling define_malloc_lazy_static. This allows define_malloc_lazy_static to be used without the
// caller needing to know about lazy_static and import its macros themselves.
//
// Credit to https://users.rust-lang.org/t/how-to-use-macro-inside-another-macro/12061/2
#[doc(hidden)]
pub use lazy_static::*;

/// Define `extern "C"` functions for the C allocation API with a non-constant initializer.
///
/// `define_malloc_lazy_static` is like `define_malloc`, except there is no requirement that the
/// initialization expression must be constant. Instead, `lazy_static` is used to construct the
/// global `Malloc` instance.
#[macro_export]
macro_rules! define_malloc_lazy_static {
    ($alloc_ty:ty, $alloc_new:expr) => {
        lazy_static! {
            static ref __HEAP: $alloc_ty = $alloc_new;
        }

        #[no_mangle]
        pub extern "C" fn malloc(size: $crate::size_t) -> *mut $crate::c_void {
            use $crate::Malloc;
            unsafe { __HEAP.c_malloc(size) }
        }

        #[no_mangle]
        pub extern "C" fn free(ptr: *mut $crate::c_void) {
            use $crate::Malloc;
            unsafe { __HEAP.c_free(ptr) }
        }

        #[cfg(target_os = "linux")]
        #[no_mangle]
        pub extern "C" fn cfree(ptr: *mut $crate::c_void) {
            use $crate::Malloc;
            unsafe { __HEAP.c_cfree(ptr) }
        }

        #[no_mangle]
        pub extern "C" fn calloc(
            nmemb: $crate::size_t,
            size: $crate::size_t,
        ) -> *mut $crate::c_void {
            use $crate::Malloc;
            unsafe { __HEAP.c_calloc(nmemb, size) }
        }

        #[cfg(any(target_os = "linux", target_os = "macos"))]
        #[no_mangle]
        pub extern "C" fn valloc(size: $crate::size_t) -> *mut $crate::c_void {
            use $crate::Malloc;
            unsafe { __HEAP.c_valloc(size) }
        }

        #[cfg(target_os = "linux")]
        #[no_mangle]
        pub extern "C" fn pvalloc(size: $crate::size_t) -> *mut $crate::c_void {
            use $crate::Malloc;
            unsafe { __HEAP.c_pvalloc(size) }
        }

        #[no_mangle]
        pub extern "C" fn realloc(
            ptr: *mut $crate::c_void,
            size: $crate::size_t,
        ) -> *mut $crate::c_void {
            use $crate::Malloc;
            unsafe { __HEAP.c_realloc(ptr, size) }
        }

        #[cfg(target_os = "macos")]
        #[no_mangle]
        pub extern "C" fn reallocf(
            ptr: *mut $crate::c_void,
            size: $crate::size_t,
        ) -> *mut $crate::c_void {
            use $crate::Malloc;
            unsafe { __HEAP.c_reallocf(ptr, size) }
        }

        #[cfg(any(target_os = "linux", target_os = "macos"))]
        #[no_mangle]
        pub extern "C" fn posix_memalign(
            memptr: *mut *mut $crate::c_void,
            alignment: $crate::size_t,
            size: $crate::size_t,
        ) -> i32 {
            use $crate::Malloc;
            unsafe { __HEAP.c_posix_memalign(memptr, alignment, size) }
        }

        #[cfg(target_os = "linux")]
        #[no_mangle]
        pub extern "C" fn memalign(
            alignment: $crate::size_t,
            size: $crate::size_t,
        ) -> *mut $crate::c_void {
            use $crate::Malloc;
            unsafe { __HEAP.c_memalign(alignment, size) }
        }

        #[cfg(target_os = "linux")]
        #[no_mangle]
        pub extern "C" fn aligned_alloc(
            alignment: $crate::size_t,
            size: $crate::size_t,
        ) -> *mut $crate::c_void {
            use $crate::Malloc;
            unsafe { __HEAP.c_aligned_alloc(alignment, size) }
        }

        #[cfg(windows)]
        #[no_mangle]
        pub extern "C" fn _aligned_malloc(
            size: $crate::size_t,
            alignment: $crate::size_t,
        ) -> *mut $crate::c_void {
            use $crate::Malloc;
            unsafe { __HEAP.c__aligned_malloc(size, alignment) }
        }
    };
}
