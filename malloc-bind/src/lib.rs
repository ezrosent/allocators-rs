// Copyright 2017 the authors. See the 'Copyright and license' section of the
// README.md file at the top-level directory of this repository.
//
// Licensed under the Apache License, Version 2.0 (the LICENSE-APACHE file) or
// the MIT license (the LICENSE-MIT file) at your option. This file may not be
// copied, modified, or distributed except according to those terms.

//! Bindings for the C `malloc` API to Rust allocators.
//!
//! This crate provides a mechanism to construct a C allocator - an implementation of `malloc`,
//! `free`, and related functions - that is backed by a Rust allocator (an implementation of the
//! `Alloc` trait).
//!
//! In order to create bindings, two things must be provided: an implementation of the `Alloc`
//! trait, and an implementation of the `LayoutFinder` trait (defined in this crate). Since the C
//! API does not provide size or alignment on `free`, but the Rust `Alloc` API requires both size
//! and alignment on `dealloc`, a mapping must be maintained between allocated objects and those
//! objects' size and alignment. The `LayoutFinder` provides this functionality.

// TODO:
// - Windows:
//   - Support _heapmin (https://msdn.microsoft.com/en-us/library/fc7etheh.aspx)
//   - Support _set_new_handler (https://msdn.microsoft.com/en-us/library/a45x8asx.aspx) (and call
//     the registered handler in various functions)

#![no_std]
#![feature(allocator_api)]
#![feature(alloc)]
#![feature(core_intrinsics)]
#![feature(const_fn)]

#[cfg(not(any(target_os = "linux", target_os = "macos", windows)))]
compile_error!("malloc-bind only supports Linux, and Mac, and Windows");

extern crate alloc;
extern crate libc;
extern crate errno;
#[cfg(any(target_os = "linux", target_os = "macos"))]
extern crate sysconf;
// lazy_static's macros are only used in the macros we define, so if no macros are called (which is
// the case when compiling this crate on its own), then lazy_static's macros (and thus the
// #[macro_use] attribute) will appear unused.  Due to an issue with clippy
// (https://rust-lang-nursery.github.io/rust-clippy/master/index.html#useless_attribute), this
// allow(unused_imports) directive will be seen as useless, so we suppress the useless_attribute
// warning as well.
#[cfg_attr(feature = "cargo-clippy", allow(useless_attribute))]
#[allow(unused_imports)]
#[macro_use]
extern crate lazy_static;
use alloc::allocator::{Alloc, AllocErr, Layout};

use libc::{c_void, size_t};
use core::ptr;

#[cfg(any(target_os = "linux", target_os = "macos"))]
const WORD_SIZE: usize = core::mem::size_of::<*mut c_void>();

/// A mechanism for mapping allocated objects to their `Layout`s.
///
/// A `LayoutFinder` is an object that can store and look up the `Layout` associated with an
/// allocated object. In the functions generated by this crate, newly-allocated objects will be
/// inserted into a global `LayoutFinder` object, and this `LayoutFinder` will be used to look up
/// the `Layout`s associated with objects passed to `free` and other functions.
///
/// # Safety
///
/// This trait is unsafe because an incorrect implementation could result in invalid arguments
/// getting passed to unsafe methods of the `Alloc` trait.
pub unsafe trait LayoutFinder {
    /// Get the `Layout` associated with an allocated object.
    ///
    /// `get_layout` is passed a pointer to an allocated object, and it returns a `Layout`
    /// describing that object. `ptr` is guaranteed to be an object previously allocated using one
    /// of the various C allocation functions.
    ///
    /// # Safety
    ///
    /// This method is unsafe because implementations may dereference `ptr`, rely on it having been
    /// allocated by this allocator, or rely on it having been inserted using `insert_layout`.
    unsafe fn get_layout(&self, ptr: *mut u8) -> Layout;

    /// Insert a new object to `Layout` mapping.
    ///
    /// `insert_layout` is passed a pointer to a newly-allocated object and a `Layout` describing
    /// that object, and it stores this mapping. `insert_layout` is called immediately after
    /// allocation in all of the C allocation functions.
    ///
    /// The default implementation of `insert_layout` is a no-op, as some allocators may already
    /// keep track of the information necessary to implement `get_layout` internally.
    ///
    /// # Safety
    ///
    /// This method is unsafe because implementations may dereference `ptr`, rely on it having been
    /// allocated by this allocator, or rely on it not having already been inserted.
    unsafe fn insert_layout(&self, _ptr: *mut u8, _layout: Layout) {}

    /// Delete an existing object to `Layout` mapping.
    ///
    /// `delete_layout` is passed a pointer to an object whose mapping has previously been
    /// inserted, and it deletes this mapping. `delete_layout` is called immediately after
    /// deallocation in all of the C deallocation functions.
    ///
    /// The default implementation of `delete_layout` is a no-op, as some allocators may already
    /// keep track of the information necessary to implement `get_layout` internally.
    ///
    /// # Safety
    ///
    /// This method is unsafe because implementations may dereference `ptr`, rely on it having been
    /// allocated by this allocator, or rely on it already having been inserted using
    /// `insert_layout`.
    unsafe fn delete_layout(&self, _ptr: *mut u8) {}
}

// See the posix_memalign manpage on Linux/Mac or https://msdn.microsoft.com/en-us/library/6ewkz86d.aspx
// on Windows.
//
// According to the posix_memalign manpage, "The glibc malloc(3) always returns 8-byte aligned
// memory addresses..." According to the linked Windows documentation, "The storage space pointed
// to by the return value is guaranteed to be suitably aligned for storage of any type of object
// that has an alignment requirement less than or equal to that of the fundamental alignment. (In
// Visual C++, the fundamental alignment is the alignment that's required for a double, or 8 bytes.
// In code that targets 64-bit platforms, itâ€™s 16 bytes.)"
//
// Thus, we align all allocations to these alignments. Since the Rust Layout type requires that
// size be a multiple of alignment, we also round up the size to be a multiple of the alignment.
//
// On Linux, it is valid for malloc(0) to return NULL, so for all 0-sized allocations, we return
// NULL. On Mac, this allowance is not explicitly documented, so we err on the side of caution and
// round up 0-sized allocations as we would any other allocation. On Windows, it is explicitly
// documented that 0-sized allocations return pointers into the heap: "If size is 0, malloc
// allocates a zero-length item in the heap and returns a valid pointer to that item." Thus, we
// round up 0-sized allocations on Windows as well.
#[cfg(not(all(windows, target_pointer_width = "64")))]
const MIN_ALIGN: size_t = 8;
#[cfg(all(windows, target_pointer_width = "64"))]
const MIN_ALIGN: size_t = 16;

/// A wrapper for a Rust allocator providing C bindings.
///
/// `Malloc` wraps existing `Alloc` and `LayoutFinder` instances and provides methods for each of
/// the various C allocation functions. Most users should simply call the `define_malloc` or
/// `define_malloc_lazy_static` macros, which take care of constructing a `Malloc` instance and
/// defining the various `extern "C"` functions of the C allocation API. Users who wish to expose
/// only a subset of this API will need to instantiate a `Malloc` and define the `extern "C"`
/// functions manually.
pub struct Malloc<A, L: LayoutFinder>
    where for<'a> &'a A: Alloc
{
    alloc: A,
    layout_finder: L,
}

impl<A, L: LayoutFinder> Malloc<A, L>
    where for<'a> &'a A: Alloc
{
    /// Construct a new `Malloc`.
    ///
    /// `new` constructs a new `Malloc` using the provided allocator and `LayoutFinder`. Since C
    /// allocation functions can be called from many threads simultaneously, the allocator must be
    /// thread-safe. Thus, `A` (the type of the `alloc` parameter) isn't required to implement
    /// `Alloc`. Instead, `&A` must implement `Alloc` so that `Alloc`'s methods can be called
    /// concurrently.
    pub const fn new(alloc: A, layout_finder: L) -> Malloc<A, L> {
        Malloc {
            alloc,
            layout_finder,
        }
    }

    /// The C `malloc` function.
    pub unsafe fn malloc(&self, size: size_t) -> *mut c_void {
        if cfg!(target_os = "linux") && size == 0 {
            return ptr::null_mut();
        }

        let size = roundup(size, MIN_ALIGN);
        let layout = layout_from_size_align(size as usize, MIN_ALIGN);
        // TODO: Check _HEAP_MAXREQ on Windows? "malloc sets errno to ENOMEM if a memory allocation
        // fails or if the amount of memory requested exceeds _HEAP_MAXREQ."
        match (&self.alloc).alloc(layout.clone()) {
            Ok(ptr) => {
                self.layout_finder.insert_layout(ptr, layout);
                ptr as *mut c_void
            }
            Err(AllocErr::Exhausted { .. }) => {
                errno::set_errno(errno::Errno(libc::ENOMEM));
                ptr::null_mut()
            }
            Err(AllocErr::Unsupported { .. }) => core::intrinsics::abort(),
        }
    }

    /// The C `free` function.
    pub unsafe fn free(&self, ptr: *mut c_void) {
        if ptr.is_null() {
            // Linux/Mac: "If ptr is a NULL pointer, no operation is performed."
            // Windows: "If memblock is NULL, the pointer is ignored and free immediately returns."
            return;
        }

        let layout = self.layout_finder.get_layout(ptr as *mut u8);
        self.layout_finder.delete_layout(ptr as *mut u8);
        (&self.alloc).dealloc(ptr as *mut u8, layout);
    }

    /// The obsolete C `cfree` function (only implemented on Linux).
    #[cfg(target_os = "linux")]
    pub unsafe fn cfree(&self, ptr: *mut c_void) {
        // See https://linux.die.net/man/3/cfree
        self.free(ptr)
    }

    /// The C `calloc` function.
    pub unsafe fn calloc(&self, nmemb: size_t, size: size_t) -> *mut c_void {
        if nmemb == 0 || size == 0 {
            return ptr::null_mut();
        }

        let total_size = roundup(nmemb * size, MIN_ALIGN);
        let layout = layout_from_size_align(total_size as usize, MIN_ALIGN);
        // TODO: Check _HEAP_MAXREQ on Windows? "calloc sets errno to ENOMEM if a memory allocation
        // fails or if the amount of memory requested exceeds _HEAP_MAXREQ."
        match (&self.alloc).alloc_zeroed(layout.clone()) {
            Ok(ptr) => {
                self.layout_finder.insert_layout(ptr, layout);
                ptr as *mut c_void
            }
            Err(AllocErr::Exhausted { .. }) => ptr::null_mut(),
            Err(AllocErr::Unsupported { .. }) => core::intrinsics::abort(),
        }
    }

    /// The obsolete C `valloc` function (only implemented on Linux and Mac).
    #[cfg(any(target_os = "linux", target_os = "macos"))]
    pub unsafe fn valloc(&self, size: size_t) -> *mut c_void {
        if size == 0 {
            return ptr::null_mut();
        }

        let pagesize = sysconf::page::pagesize();
        let size = roundup(size, pagesize);
        let layout = layout_from_size_align(size as usize, pagesize);
        match (&self.alloc).alloc(layout.clone()) {
            Ok(ptr) => {
                self.layout_finder.insert_layout(ptr, layout);
                ptr as *mut c_void
            }
            Err(AllocErr::Exhausted { .. }) => ptr::null_mut(),
            Err(AllocErr::Unsupported { .. }) => core::intrinsics::abort(),
        }
    }

    /// The obsolete C `pvalloc` function (only implemented on Linux).
    #[cfg(target_os = "linux")]
    pub unsafe fn pvalloc(&self, size: size_t) -> *mut c_void {
        // See http://man7.org/linux/man-pages/man3/posix_memalign.3.html

        if size == 0 {
            return ptr::null_mut();
        }

        let pagesize = sysconf::page::pagesize();
        let size = roundup(size, pagesize);
        let layout = layout_from_size_align(size as usize, pagesize);
        match (&self.alloc).alloc(layout.clone()) {
            Ok(ptr) => {
                self.layout_finder.insert_layout(ptr, layout);
                ptr as *mut c_void
            }
            Err(AllocErr::Exhausted { .. }) => ptr::null_mut(),
            Err(AllocErr::Unsupported { .. }) => core::intrinsics::abort(),
        }
    }

    /// The C `realloc` function.
    pub unsafe fn realloc(&self, ptr: *mut c_void, size: size_t) -> *mut c_void {
        // See http://man7.org/linux/man-pages/man3/malloc.3.html,
        // http://www.manpagez.com/man/3/malloc/osx-10.6.php

        if ptr.is_null() {
            // Linux: "If ptr is NULL, then the call is equivalent to malloc(size), for all values
            // of size."
            // Mac: "If ptr is NULL, realloc() is identical to a call to malloc() for size bytes."
            // Windows: "If memblock is NULL, realloc behaves the same way as malloc and allocates
            // a new block of size bytes."
            return self.malloc(size);
        }

        if cfg!(any(target_os = "linux", windows)) && size == 0 {
            // Linux: "if size is equal to zero, and ptr is not NULL, then the call is equivalent
            // to free(ptr)."
            // Windows (https://msdn.microsoft.com/en-us/library/xbebcx7d.aspx): "If size is zero,
            // then the block pointed to by [ptr] is freed; the return value is NULL, and [ptr] is
            // left pointing at a freed block."
            self.free(ptr);
            return ptr::null_mut();
        }

        // Mac: "If size is zero and ptr is not NULL, a new, minimum sized object is allocated
        // and the original object is freed."
        //
        // Since "minimum sized object" isn't defined in the manpage, we take it to mean an object
        // at least as large as the minimum alignment. Luckily, we don't need any special-cased
        // logic since 'roundup(size, MIN_ALIGN)' will handle this for us. Note that while the
        // manpage requires that a new object is allocated and the old one freed, realloc'ing works
        // just as well because the caller cannot rely on the contents of a newly-allocated object,
        // and thus the new object sharing memory with the old object is fine.

        let size = roundup(size, MIN_ALIGN);
        let layout = self.layout_finder.get_layout(ptr as *mut u8);
        let new_layout = layout_from_size_align(size as usize, MIN_ALIGN);
        match (&self.alloc).realloc(ptr as *mut u8, layout, new_layout.clone()) {
            Ok(ptr) => {
                self.layout_finder.delete_layout(ptr);
                self.layout_finder.insert_layout(ptr, new_layout);
                ptr as *mut c_void
            }
            Err(AllocErr::Exhausted { .. }) => {
                // Linux: "The realloc() function returns... NULL if the request fails... If
                // realloc() fails, the original block is left untouched; it is not freed or
                // moved."
                // Mac: "If there is an error, [realloc] return[s] a NULL pointer and set[s] errno
                // to ENOMEM. For realloc(), the input pointer is still valid if reallocation
                // failed."
                // Windows: "If there is not enough available memory to expand the block to the
                // given size, the original block is left unchanged, and NULL is returned."
                errno::set_errno(errno::Errno(libc::ENOMEM));
                ptr::null_mut()
            }
            Err(AllocErr::Unsupported { .. }) => core::intrinsics::abort(),
        }
    }

    /// The C `reallocf` function (only implemented on Mac).
    #[cfg(target_os = "macos")]
    pub unsafe fn reallocf(&self, ptr: *mut c_void, size: size_t) -> *mut c_void {
        // See http://www.manpagez.com/man/3/malloc/osx-10.6.php

        if ptr.is_null() {
            return self.malloc(size);
        }

        // According to the reallocf manpage: "If size is zero and ptr is not NULL, a new, minimum
        // sized object is allocated and the original object is freed." See the equivalent comment
        // in realloc for why this is handled automatically.

        let size = roundup(size, MIN_ALIGN);
        let layout = self.layout_finder.get_layout(ptr as *mut u8);
        let new_layout = layout_from_size_align(size as usize, MIN_ALIGN);
        match (&self.alloc).realloc(ptr as *mut u8, layout, new_layout.clone()) {
            Ok(ptr) => {
                self.layout_finder.delete_layout(ptr);
                self.layout_finder.insert_layout(ptr, new_layout);
                ptr as *mut c_void
            }
            Err(AllocErr::Exhausted { .. }) => {
                self.free(ptr);
                ptr::null_mut()
            }
            Err(AllocErr::Unsupported { .. }) => core::intrinsics::abort(),
        }
    }

    /// The C `reallocarray` function (only implemented on Linux).
    #[cfg(target_os = "linux")]
    pub unsafe fn reallocarray(&self,
                               ptr: *mut c_void,
                               nmemb: size_t,
                               size: size_t)
                               -> *mut c_void {
        // See http://man7.org/linux/man-pages/man3/malloc.3.html

        // According to the reallocarray manpage, "unlike that realloc() call, reallocarray() fails
        // safely in the case where the multiplication would overflow. If such an overflow occurs,
        // reallocarray() returns NULL, sets errno to ENOMEM, and leaves the original block of
        // memory unchanged."
        match nmemb.checked_mul(size) {
            Some(product) => self.realloc(ptr, product),
            None => {
                errno::set_errno(errno::Errno(libc::ENOMEM));
                ptr::null_mut()
            }
        }
    }


    /// The C `posix_memalign` function (only implemented on Linux and Mac).
    #[cfg(any(target_os = "linux", target_os = "macos"))]
    pub unsafe fn posix_memalign(&self,
                                 memptr: *mut *mut c_void,
                                 alignment: size_t,
                                 size: size_t)
                                 -> i32 {
        // See http://man7.org/linux/man-pages/man3/posix_memalign.3.html

        // NOTE: Unlike most other allocation functions, posix_memalign signals failure by
        // returning an error value rather than by setting errno.

        // The manpage also specifies that the alignment must be a multiple of the word size, but
        // all powers of two greater than or equal to the word size are multiples of the word size,
        // so we omit that check.
        if alignment <= WORD_SIZE || !alignment.is_power_of_two() {
            return libc::EINVAL;
        }

        if size == 0 {
            *memptr = ptr::null_mut();
            return 0;
        }

        // posix_memalign does not require that size is a multiple of alignment. Thus, we manually
        // round up since valid Layouts must have that property. This is safe because this API
        // never takes the memory region size on deallocation, so it's fine that the caller might
        // think they have a smaller memory region than they actually do.
        let size = roundup(size, alignment);
        let layout = layout_from_size_align(size as usize, alignment);
        match (&self.alloc).alloc(layout.clone()) {
            Ok(ptr) => {
                self.layout_finder.insert_layout(ptr, layout);
                *memptr = ptr as *mut c_void;
                0
            }
            Err(AllocErr::Exhausted { .. }) => libc::ENOMEM,
            Err(AllocErr::Unsupported { .. }) => core::intrinsics::abort(),
        }
    }

    /// The obsolete C `memalign` function (only implemented on Linux).
    #[cfg(target_os = "linux")]
    pub unsafe fn memalign(&self, alignment: size_t, size: size_t) -> *mut c_void {
        // See http://man7.org/linux/man-pages/man3/posix_memalign.3.html

        if !alignment.is_power_of_two() {
            errno::set_errno(errno::Errno(libc::EINVAL));
            return ptr::null_mut();
        }

        if size == 0 {
            return ptr::null_mut();
        }

        // memalign does not require that size is a multiple of alignment. Thus, we manually round
        // up since valid Layouts must have that property. This is safe because this API never
        // takes the memory region size on deallocation, so it's fine that the caller might think
        // they have a smaller memory region than they actually do.
        let size = roundup(size, alignment);
        let layout = layout_from_size_align(size as usize, alignment);
        match (&self.alloc).alloc(layout.clone()) {
            Ok(ptr) => {
                self.layout_finder.insert_layout(ptr, layout);
                ptr as *mut c_void
            }
            Err(AllocErr::Exhausted { .. }) => {
                errno::set_errno(errno::Errno(libc::ENOMEM));
                ptr::null_mut()
            }
            Err(AllocErr::Unsupported { .. }) => core::intrinsics::abort(),
        }
    }

    /// The C `aligned_alloc` function (only implemented on Linux).
    #[cfg(target_os = "linux")]
    pub unsafe fn aligned_alloc(&self, alignment: size_t, size: size_t) -> *mut c_void {
        // See http://man7.org/linux/man-pages/man3/posix_memalign.3.html

        // From the aligned_alloc manpage: "The function aligned_alloc() is the same as memalign(),
        // except for the added restriction that size should be a multiple of alignment."
        if size % alignment != 0 {
            errno::set_errno(errno::Errno(libc::EINVAL));
            return ptr::null_mut();
        }
        self.memalign(alignment, size)
    }

    /// The C '_aligned_malloc' function (only implemented on Windows).
    #[cfg(windows)]
    pub unsafe fn _aligned_malloc(&self, size: size_t, alignment: size_t) -> *mut c_void {
        // See https://msdn.microsoft.com/en-us/library/8z34s9c6.aspx

        if !alignment.is_power_of_two() || size == 0 {
            // TODO: Call invalid parameter handler (see documentation). Blocked on this issue:
            // https://github.com/retep998/winapi-rs/issues/493
            errno::set_errno(errno::Errno(libc::EINVAL));
            return ptr::null_mut();
        }

        // _aligned_malloc does not require that size is a multiple of alignment. Thus, we manually
        // round up since valid Layouts must have that property. This is safe because this API
        // never takes the memory region size on deallocation, so it's fine that the caller might
        // think they have a smaller memory region than they actually do.
        let size = roundup(size, alignment);
        let layout = layout_from_size_align(size as usize, alignment);
        match (&self.alloc).alloc(layout.clone()) {
            Ok(ptr) => {
                self.layout_finder.insert_layout(ptr, layout);
                ptr as *mut c_void
            }
            Err(AllocErr::Exhausted { .. }) => {
                errno::set_errno(errno::Errno(libc::ENOMEM));
                ptr::null_mut()
            }
            Err(AllocErr::Unsupported { .. }) => core::intrinsics::abort(),
        }
    }
}

#[cfg_attr(feature = "cargo-clippy", allow(inline_always))]
#[inline(always)]
fn roundup(n: size_t, multiple: size_t) -> size_t {
    if n == 0 {
        return multiple;
    }
    let remainder = n % multiple;
    if remainder == 0 {
        n
    } else {
        n + multiple - remainder
    }
}

#[cfg_attr(feature = "cargo-clippy", allow(inline_always))]
#[inline(always)]
unsafe fn layout_from_size_align(size: usize, align: usize) -> Layout {
    if cfg!(debug_assertions) {
        Layout::from_size_align(size as usize, align).unwrap()
    } else {
        Layout::from_size_align_unchecked(size as usize, align)
    }
}

/// Define `extern "C"` functions for the C allocation API.
///
/// `define_malloc` is a convenience macro that constructs a global instance of `Malloc` and
/// defines each of the functions of the C allocation API by calling methods on that instance. One
/// function is defined for each of the methods on `Malloc`. Users who only want to define a subset
/// of the C allocation API should instead define these functions manually.
///
/// `define_malloc` takes an allocator type, an expression to construct a new instance of that
/// type, a `LayoutFinder` type, and an expression to construct a new instance of that type. Both
/// expressions must be constant expressions, as they will be used in the initialization of a
/// static variable.
#[macro_export]
macro_rules! define_malloc {
    ($alloc_ty:ty, $alloc_new:expr, $layout_finder_ty:ty, $layout_finder_new:expr) => (
        static HEAP: $crate::Malloc<$alloc_ty, $layout_finder_ty> = $crate::Malloc::new($alloc_new, $layout_finder_new);

        #[no_mangle]
        pub extern "C" fn malloc(size: size_t) -> *mut c_void {
            unsafe { HEAP.malloc(size) }
        }

        #[no_mangle]
        pub extern "C" fn free(ptr: *mut c_void) {
            unsafe { HEAP.free(ptr) }
        }

        #[cfg(target_os = "linux")]
        #[no_mangle]
        pub extern "C" fn cfree(ptr: *mut c_void) {
            unsafe { HEAP.cfree(ptr) }
        }

        #[no_mangle]
        pub extern "C" fn calloc(nmemb: size_t, size: size_t) -> *mut c_void {
            unsafe { HEAP.calloc(nmemb, size) }
        }

        #[cfg(any(target_os = "linux", target_os = "macos"))]
        #[no_mangle]
        pub extern "C" fn valloc(size: size_t) -> *mut c_void {
            unsafe { HEAP.valloc(size) }
        }

        #[cfg(target_os = "linux")]
        #[no_mangle]
        pub extern "C" fn pvalloc(size: size_t) -> *mut c_void {
            unsafe { HEAP.pvalloc(size) }
        }

        #[no_mangle]
        pub extern "C" fn realloc(ptr: *mut c_void, size: size_t) -> *mut c_void {
            unsafe { HEAP.realloc(ptr, size) }
        }

        #[cfg(target_os = "macos")]
        #[no_mangle]
        pub extern "C" fn reallocf(ptr: *mut c_void, size: size_t) -> *mut c_void {
            unsafe { HEAP.reallocf(ptr, size) }
        }

        #[cfg(target_os = "linux")]
        pub extern "C" fn reallocarray(ptr: *mut c_void, nmemb: size_t, size: size_t) -> *mut c_void {
            unsafe { HEAP.reallocarray(ptr, nmemb, size) }
        }

        #[cfg(any(target_os = "linux", target_os = "macos"))]
        #[no_mangle]
        pub extern "C" fn posix_memalign(memptr: *mut *mut c_void, alignment: size_t, size: size_t) -> i32 {
            unsafe { HEAP.posix_memalign(memptr, alignment, size) }
        }

        #[cfg(target_os = "linux")]
        #[no_mangle]
        pub extern "C" fn memalign(alignment: size_t, size: size_t) -> *mut c_void {
            unsafe { HEAP.memalign(alignment, size) }
        }

        #[cfg(target_os = "linux")]
        #[no_mangle]
        pub extern "C" fn aligned_alloc(alignment: size_t, size: size_t) -> *mut c_void {
            unsafe { HEAP.aligned_alloc(alignment, size) }
        }

        #[cfg(windows)]
        #[no_mangle]
        pub extern "C" fn _aligned_malloc(size: size_t, alignment: size_t) -> *mut c_void {
            unsafe { HEAP._aligned_malloc(size, alignment) }
        }
    )
}

// This line re-exports the macros from lazy_static so that they'll be available to the code
// calling define_malloc_lazy_static. This allows define_malloc_lazy_static to be used without the
// caller needing to know about lazy_static and import its macros themselves.
//
// Credit to https://users.rust-lang.org/t/how-to-use-macro-inside-another-macro/12061/2
pub use lazy_static::*;

/// Define `extern "C"` functions for the C allocation API with non-constant initializers.
///
/// `define_malloc_lazy_static` is like `define_malloc`, except there is no requirement that the
/// initialization expressions must be constant. Instead, `lazy_static` is used to construct the
/// global `Malloc` instance.
#[macro_export]
macro_rules! define_malloc_lazy_static {
    ($alloc_ty:ty, $alloc_new:expr, $layout_finder_ty:ty, $layout_finder_new:expr) => (
        lazy_static!{
            static ref HEAP: $crate::Malloc<$alloc_ty, $layout_finder_ty> = $crate::Malloc::new($alloc_new, $layout_finder_new);
        }

        #[no_mangle]
        pub extern "C" fn malloc(size: size_t) -> *mut c_void {
            unsafe { HEAP.malloc(size) }
        }

        #[no_mangle]
        pub extern "C" fn free(ptr: *mut c_void) {
            unsafe { HEAP.free(ptr) }
        }

        #[cfg(target_os = "linux")]
        #[no_mangle]
        pub extern "C" fn cfree(ptr: *mut c_void) {
            unsafe { HEAP.cfree(ptr) }
        }

        #[no_mangle]
        pub extern "C" fn calloc(nmemb: size_t, size: size_t) -> *mut c_void {
            unsafe { HEAP.calloc(nmemb, size) }
        }

        #[cfg(any(target_os = "linux", target_os = "macos"))]
        #[no_mangle]
        pub extern "C" fn valloc(size: size_t) -> *mut c_void {
            unsafe { HEAP.valloc(size) }
        }

        #[cfg(target_os = "linux")]
        #[no_mangle]
        pub extern "C" fn pvalloc(size: size_t) -> *mut c_void {
            unsafe { HEAP.pvalloc(size) }
        }

        #[no_mangle]
        pub extern "C" fn realloc(ptr: *mut c_void, size: size_t) -> *mut c_void {
            unsafe { HEAP.realloc(ptr, size) }
        }

        #[cfg(target_os = "macos")]
        #[no_mangle]
        pub extern "C" fn reallocf(ptr: *mut c_void, size: size_t) -> *mut c_void {
            unsafe { HEAP.reallocf(ptr, size) }
        }

        #[cfg(target_os = "linux")]
        pub extern "C" fn reallocarray(ptr: *mut c_void, nmemb: size_t, size: size_t) -> *mut c_void {
            unsafe { HEAP.reallocarray(ptr, nmemb, size) }
        }

        #[cfg(any(target_os = "linux", target_os = "macos"))]
        #[no_mangle]
        pub extern "C" fn posix_memalign(memptr: *mut *mut c_void, alignment: size_t, size: size_t) -> i32 {
            unsafe { HEAP.posix_memalign(memptr, alignment, size) }
        }

        #[cfg(target_os = "linux")]
        #[no_mangle]
        pub extern "C" fn memalign(alignment: size_t, size: size_t) -> *mut c_void {
            unsafe { HEAP.memalign(alignment, size) }
        }

        #[cfg(target_os = "linux")]
        #[no_mangle]
        pub extern "C" fn aligned_alloc(alignment: size_t, size: size_t) -> *mut c_void {
            unsafe { HEAP.aligned_alloc(alignment, size) }
        }

        #[cfg(windows)]
        #[no_mangle]
        pub extern "C" fn _aligned_malloc(size: size_t, alignment: size_t) -> *mut c_void {
            unsafe { HEAP._aligned_malloc(size, alignment) }
        }
    )
}
